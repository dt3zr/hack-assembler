package assembler

import (
	"bufio"
	"bytes"
	"io"
	"strings"
	"testing"
)

// func TestParserOnDoubleInstruction(t *testing.T) {
// 	buf := bytes.NewBufferString("AMD=M-D\nD=A+1\n")
// 	out := strings.Builder{}

// 	p := newParser(buf, &out)
// 	err := p.parse()

// 	fmt.Println(out.String())

// 	if err != nil {
// 		t.Fatalf("Expected err to be nil but err is %v\n", err)
// 	}

// }

func TestParserOnSingleInstruction(t *testing.T) {
	cases := []struct {
		in   string
		want string
	}{
		{"AMD=M-D\n", "1111000111111000"},
		{"AM=M-D\n", "1111000111101000"},
		{"AD=M-D\n", "1111000111110000"},
		{"A=M-D\n", "1111000111100000"},
		{"M=M-D\n", "1111000111001000"},
		{"D=M-D\n", "1111000111010000"},
		{"M-D\n", "1111000111000000"},
		{"AMD=M-1\n", "1111110010111000"},
		{"AM=M-1\n", "1111110010101000"},
		{"AD=M-1\n", "1111110010110000"},
		{"A=M-1\n", "1111110010100000"},
		{"M=M-1\n", "1111110010001000"},
		{"D=M-1\n", "1111110010010000"},
		{"M-1\n", "1111110010000000"},
		{"AMD=M+1\n", "1111110111111000"},
		{"AM=M+1\n", "1111110111101000"},
		{"AD=M+1\n", "1111110111110000"},
		{"A=M+1\n", "1111110111100000"},
		{"M=M+1\n", "1111110111001000"},
		{"D=M+1\n", "1111110111010000"},
		{"M+1\n", "1111110111000000"},
		{"AMD=A-D\n", "1110000111111000"},
		{"AM=A-D\n", "1110000111101000"},
		{"AD=A-D\n", "1110000111110000"},
		{"A=A-D\n", "1110000111100000"},
		{"M=A-D\n", "1110000111001000"},
		{"D=A-D\n", "1110000111010000"},
		{"A-D\n", "1110000111000000"},
		{"AMD=A-1\n", "1110110010111000"},
		{"AM=A-1\n", "1110110010101000"},
		{"AD=A-1\n", "1110110010110000"},
		{"A=A-1\n", "1110110010100000"},
		{"M=A-1\n", "1110110010001000"},
		{"D=A-1\n", "1110110010010000"},
		{"A-1\n", "1110110010000000"},
		{"AMD=A+1\n", "1110110111111000"},
		{"AM=A+1\n", "1110110111101000"},
		{"AD=A+1\n", "1110110111110000"},
		{"A=A+1\n", "1110110111100000"},
		{"M=A+1\n", "1110110111001000"},
		{"D=A+1\n", "1110110111010000"},
		{"A+1\n", "1110110111000000"},
		{"AMD=A\n", "1110110000111000"},
		{"AM=A\n", "1110110000101000"},
		{"AD=A\n", "1110110000110000"},
		{"A=A\n", "1110110000100000"},
		{"M=A\n", "1110110000001000"},
		{"D=A\n", "1110110000010000"},
		{"A\n", "1110110000000000"},
		{"AMD=M\n", "1111110000111000"},
		{"AM=M\n", "1111110000101000"},
		{"AD=M\n", "1111110000110000"},
		{"A=M\n", "1111110000100000"},
		{"M=M\n", "1111110000001000"},
		{"D=M\n", "1111110000010000"},
		{"M\n", "1111110000000000"},
		{"AMD=D\n", "1110001100111000"},
		{"AM=D\n", "1110001100101000"},
		{"AD=D\n", "1110001100110000"},
		{"A=D\n", "1110001100100000"},
		{"A=D\n", "1110001100100000"},
		{"M=D\n", "1110001100001000"},
		{"D=D\n", "1110001100010000"},
		{"D\n", "1110001100000000"},
		{"AMD=D+1\n", "1110011111111000"},
		{"AM=D+1\n", "1110011111101000"},
		{"AD=D+1\n", "1110011111110000"},
		{"A=D+1\n", "1110011111100000"},
		{"M=D+1\n", "1110011111001000"},
		{"D=D+1\n", "1110011111010000"},
		{"D+1\n", "1110011111000000"},
		{"AMD=D-1\n", "1110001110111000"},
		{"AM=D-1\n", "1110001110101000"},
		{"AD=D-1\n", "1110001110110000"},
		{"A=D-1\n", "1110001110100000"},
		{"M=D-1\n", "1110001110001000"},
		{"D=D-1\n", "1110001110010000"},
		{"D-1\n", "1110001110000000"},
		{"AMD=D+A\n", "1110000010111000"},
		{"AM=D+A\n", "1110000010101000"},
		{"AD=D+A\n", "1110000010110000"},
		{"A=D+A\n", "1110000010100000"},
		{"M=D+A\n", "1110000010001000"},
		{"D=D+A\n", "1110000010010000"},
		{"D+A\n", "1110000010000000"},
		{"AMD=D+M\n", "1111000010111000"},
		{"AM=D+M\n", "1111000010101000"},
		{"AD=D+M\n", "1111000010110000"},
		{"A=D+M\n", "1111000010100000"},
		{"M=D+M\n", "1111000010001000"},
		{"D=D+M\n", "1111000010010000"},
		{"D+M\n", "1111000010000000"},
		{"AMD=D-A\n", "1110010011111000"},
		{"AM=D-A\n", "1110010011101000"},
		{"AD=D-A\n", "1110010011110000"},
		{"A=D-A\n", "1110010011100000"},
		{"M=D-A\n", "1110010011001000"},
		{"D=D-A\n", "1110010011010000"},
		{"D-A\n", "1110010011000000"},
		{"AMD=D-M\n", "1111010011111000"},
		{"AM=D-M\n", "1111010011101000"},
		{"AD=D-M\n", "1111010011110000"},
		{"A=D-M\n", "1111010011100000"},
		{"M=D-M\n", "1111010011001000"},
		{"D=D-M\n", "1111010011010000"},
		{"D-M\n", "1111010011000000"},
		{"AMD=D&A\n", "1110000000111000"},
		{"AM=D&A\n", "1110000000101000"},
		{"AD=D&A\n", "1110000000110000"},
		{"A=D&A\n", "1110000000100000"},
		{"M=D&A\n", "1110000000001000"},
		{"D=D&A\n", "1110000000010000"},
		{"D&A\n", "1110000000000000"},
		{"AMD=D&M\n", "1111000000111000"},
		{"AM=D&M\n", "1111000000101000"},
		{"AD=D&M\n", "1111000000110000"},
		{"A=D&M\n", "1111000000100000"},
		{"M=D&M\n", "1111000000001000"},
		{"D=D&M\n", "1111000000010000"},
		{"D&M\n", "1111000000000000"},
		{"AMD=D|A\n", "1110010101111000"},
		{"AM=D|A\n", "1110010101101000"},
		{"AD=D|A\n", "1110010101110000"},
		{"A=D|A\n", "1110010101100000"},
		{"M=D|A\n", "1110010101001000"},
		{"D=D|A\n", "1110010101010000"},
		{"D|A\n", "1110010101000000"},
		{"AMD=D|M\n", "1111010101111000"},
		{"AM=D|M\n", "1111010101101000"},
		{"AD=D|M\n", "1111010101110000"},
		{"A=D|M\n", "1111010101100000"},
		{"M=D|M\n", "1111010101001000"},
		{"D=D|M\n", "1111010101010000"},
		{"D|M\n", "1111010101000000"},
		{"AMD=0\n", "1110101010111000"},
		{"AM=0\n", "1110101010101000"},
		{"AD=0\n", "1110101010110000"},
		{"A=0\n", "1110101010100000"},
		{"M=0\n", "1110101010001000"},
		{"D=0\n", "1110101010010000"},
		{"0\n", "1110101010000000"},
		{"AMD=1\n", "1110111111111000"},
		{"AM=1\n", "1110111111101000"},
		{"AD=1\n", "1110111111110000"},
		{"A=1\n", "1110111111100000"},
		{"M=1\n", "1110111111001000"},
		{"D=1\n", "1110111111010000"},
		{"1\n", "1110111111000000"},
		{"AMD=-1\n", "1110111010111000"},
		{"AM=-1\n", "1110111010101000"},
		{"AD=-1\n", "1110111010110000"},
		{"A=-1\n", "1110111010100000"},
		{"M=-1\n", "1110111010001000"},
		{"D=-1\n", "1110111010010000"},
		{"-1\n", "1110111010000000"},
		{"AMD=-A\n", "1110110011111000"},
		{"AM=-A\n", "1110110011101000"},
		{"AD=-A\n", "1110110011110000"},
		{"A=-A\n", "1110110011100000"},
		{"M=-A\n", "1110110011001000"},
		{"D=-A\n", "1110110011010000"},
		{"-A\n", "1110110011000000"},
		{"AMD=-M\n", "1111110011111000"},
		{"AM=-M\n", "1111110011101000"},
		{"AD=-M\n", "1111110011110000"},
		{"A=-M\n", "1111110011100000"},
		{"M=-M\n", "1111110011001000"},
		{"D=-M\n", "1111110011010000"},
		{"-M\n", "1111110011000000"},
		{"AMD=-D\n", "1110001111111000"},
		{"AM=-D\n", "1110001111101000"},
		{"AD=-D\n", "1110001111110000"},
		{"A=-D\n", "1110001111100000"},
		{"M=-D\n", "1110001111001000"},
		{"D=-D\n", "1110001111010000"},
		{"-D\n", "1110001111000000"},
		{"AMD=!A\n", "1110110001111000"},
		{"AM=!A\n", "1110110001101000"},
		{"AD=!A\n", "1110110001110000"},
		{"A=!A\n", "1110110001100000"},
		{"M=!A\n", "1110110001001000"},
		{"D=!A\n", "1110110001010000"},
		{"!A\n", "1110110001000000"},
		{"AMD=!M\n", "1111110001111000"},
		{"AM=!M\n", "1111110001101000"},
		{"AD=!M\n", "1111110001110000"},
		{"A=!M\n", "1111110001100000"},
		{"M=!M\n", "1111110001001000"},
		{"D=!M\n", "1111110001010000"},
		{"!M\n", "1111110001000000"},
		{"AMD=!D\n", "1110001101111000"},
		{"AM=!D\n", "1110001101101000"},
		{"AD=!D\n", "1110001101110000"},
		{"A=!D\n", "1110001101100000"},
		{"M=!D\n", "1110001101001000"},
		{"D=!D\n", "1110001101010000"},
		{"!D\n", "1110001101000000"},
		{"@0\n", "0000000000000000"},
		{"@1\n", "0000000000000001"},
		{"@16\n", "0000000000010000"},
		{"@100\n", "0000000001100100"},
		{"@16384\n", "0100000000000000"},
		{"@24576\n", "0110000000000000"},
		{"0;JMP\n", "1110101010000111"},
		{"AMD=M-D;JNE\n", "1111000111111101"},
		{"AM=M-1;JEQ\n", "1111110010101010"},
		{"A=M+1;JGE\n", "1111110111100011"},
		{"A-D;JGT\n", "1110000111000001"},
		{"D;JLE\n", "1110001100000110"},
		{"D;JGT\n", "1110001100000001"},
		{"M=D+M;JLT\n", "1111000010001100"},
		{"AMD=D|M;JNE\n", "1111010101111101"},
		{"A=0;JMP\n", "1110101010100111"},
	}

	for _, c := range cases {
		buf := bytes.NewBufferString(c.in)
		out := strings.Builder{}

		p := newParser(buf, &out)
		err := p.parse()
		outString := strings.TrimSpace(out.String())

		if outString != c.want || err != nil {
			t.Fatalf("Expected %v but string is %s\n", c, outString)
		}

	}

}

const hackForLoop string = `@16
M=0
@5
D=M
@17
M=D
@18
M=0
@18
D=M
@17
D=M-D
@18
D; JEQ
@18
M=M+1
@8
0;JMP
@18
0;JMP

`

const hackForLoopBin string = `0000000000010000
1110101010001000
0000000000000101
1111110000010000
0000000000010001
1110001100001000
0000000000010010
1110101010001000
0000000000010010
1111110000010000
0000000000010001
1111000111010000
0000000000010010
1110001100000010
0000000000010010
1111110111001000
0000000000001000
1110101010000111
0000000000010010
1110101010000111
`

const hackDrawRectangle string = `@4
D=M
@0
M=D
@16
M=0
@17
M=0
@16384
D=A
@18
M=D
@19
M=D
@16
D=M
@0
D=M-D
@22
D;JGT
@51
0;JMP
@17
D=M
@0
D=D-M
@30
D; JLT
@39
0;JMP
@18
A=M
M=-1
@18
M=M+1
@17
M=M+1
@22
0;JMP
@32
D=A
@19
MD=D+M
@18
M=D
@16
M=M+1
@17
M=0
@14
0;JMP
@51
0;JMP

`

const hackDrawRectangleBin string = `0000000000000100
1111110000010000
0000000000000000
1110001100001000
0000000000010000
1110101010001000
0000000000010001
1110101010001000
0100000000000000
1110110000010000
0000000000010010
1110001100001000
0000000000010011
1110001100001000
0000000000010000
1111110000010000
0000000000000000
1111000111010000
0000000000010110
1110001100000001
0000000000110011
1110101010000111
0000000000010001
1111110000010000
0000000000000000
1111010011010000
0000000000011110
1110001100000100
0000000000100111
1110101010000111
0000000000010010
1111110000100000
1110111010001000
0000000000010010
1111110111001000
0000000000010001
1111110111001000
0000000000010110
1110101010000111
0000000000100000
1110110000010000
0000000000010011
1111000010011000
0000000000010010
1110001100001000
0000000000010000
1111110111001000
0000000000010001
1110101010001000
0000000000001110
1110101010000111
0000000000110011
1110101010000111
`

func TestParser(t *testing.T) {
	cases := []struct {
		id   string
		in   string
		want string
	}{
		{"hackForLoop", hackForLoop, hackForLoopBin},
		{"hackDrawRectangle", hackDrawRectangle, hackDrawRectangleBin},
	}

	for _, c := range cases {
		buf := bytes.NewBufferString(c.in)
		out := strings.Builder{}

		p := newParser(buf, &out)
		p.parse()
		outString := out.String()

		outStringReader := bufio.NewReader(strings.NewReader(outString))
		wantReader := bufio.NewReader(strings.NewReader(c.want))

		a, aerr := wantReader.ReadString('\n')
		b, berr := outStringReader.ReadString('\n')
		i := 1

		for true {
			if aerr == io.EOF && berr == io.EOF {
				break
			} else if aerr == io.EOF {
				t.Fatalf("For %s, expected is EOF and at line %d, assembled output unmatched\nLine %d: %s", c.id, i, i, b)
			} else if berr == io.EOF {
				t.Fatalf("For %s, target is EOF and at line %d, assembled output unmatched\nLine %d: %s", c.id, i, i, a)
			}

			if a != b {
				t.Fatalf("For %s, at line %d, assembled output unmatched\nLine %d: expected -> %s\nbut got -> %s", c.id, i, i, a, b)
			}

			a, aerr = wantReader.ReadString('\n')
			b, berr = outStringReader.ReadString('\n')
			i++
		}

	}
}

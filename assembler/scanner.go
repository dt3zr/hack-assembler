package assembler

import (
	"bufio"
	"errors"
	"fmt"
	"io"
	"log"
)

type stateMachineStatus byte

const (
	stateReject stateMachineStatus = iota
)

const (
	startAcceptableStates stateMachineStatus = 16 + iota
	stateAccept
	stateRepeatable
)

type token struct {
	id     symbolID
	lexeme string
}

const asciiTableSize int = 128
const transitionTableLength int = 27
const stateSize int = 12
const logicalStateSize int = stateSize + 17

var transitionIndex = [asciiTableSize]byte{
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x16, 0xff, 0xff, 0x16, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x14, 0xff, 0xff, 0xff, 0xff, 0x12, 0xff, 0x18, 0x19, 0xff, 0x11, 0xff, 0x10, 0xff, 0xff,
	0x0a, 0x0b, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0xff, 0x15, 0xff, 0x0f, 0xff, 0xff,
	0x09, 0x0d, 0x17, 0x17, 0x0e, 0x03, 0x17, 0x01, 0x17, 0x17, 0x00, 0x23, 0x02, 0x07, 0x06, 0x17,
	0x08, 0x05, 0x17, 0x17, 0x04, 0x17, 0x17, 0x17, 0x17, 0x17, 0x17, 0xff, 0xff, 0xff, 0xff, 0x1a,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x13, 0xff, 0xff, 0xff,
}

var transitionTable = [transitionTableLength][stateSize]byte{
	//  0     1     2     3     4     5     6     7     8     9    10    11
	{0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x09, 0xff, 0x09, 0x0b, 0x0b}, // 0
	{0xff, 0x02, 0xff, 0xff, 0xff, 0xff, 0xff, 0x09, 0xff, 0x09, 0x0b, 0x0b}, // 1
	{0xff, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0x09, 0xff, 0x09, 0x0b, 0x0b}, // 2
	{0xff, 0x04, 0x0d, 0x0d, 0xff, 0x0d, 0xff, 0x09, 0xff, 0x09, 0x0b, 0x0b}, // 3
	{0xff, 0xff, 0x0d, 0x0d, 0xff, 0xff, 0xff, 0x09, 0xff, 0x09, 0x0b, 0x0b}, // 4
	{0xff, 0xff, 0xff, 0xff, 0x0d, 0xff, 0xff, 0x09, 0xff, 0x09, 0x0b, 0x0b}, // 5
	{0xff, 0x05, 0xff, 0xff, 0xff, 0xff, 0xff, 0x09, 0xff, 0x09, 0x0b, 0x0b}, // 6
	{0x0e, 0x06, 0xff, 0xff, 0xff, 0xff, 0xff, 0x09, 0xff, 0x09, 0x0b, 0x0b}, // 7
	{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0d, 0x09, 0xff, 0x09, 0x0b, 0x0b}, // 8
	{0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, // 9
	{0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x08, 0x08, 0x09, 0xff, 0x0b}, // 10
	{0x10, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x08, 0x08, 0x09, 0xff, 0x0b}, // 11
	{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x08, 0x08, 0x09, 0xff, 0x0b}, // 12
	{0x11, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x09, 0x0b, 0x0b}, // 13
	{0x12, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x09, 0x0b, 0x0b}, // 14
	{0x13, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, // 15
	{0x14, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, // 16
	{0x15, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, // 17
	{0x16, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, // 18
	{0x17, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, // 19
	{0x18, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, // 20
	{0x19, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, // 21
	{0x1a, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x1b, 0x1c, 0xff, 0xff}, // 22
	{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x09, 0xff, 0x09, 0x0b, 0x0b}, // 23
	{0x0a, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}, // 24
	{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0c}, // 25
	{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x09, 0xff, 0x09, 0x0b, 0x0b}, // 26
}

var acceptStates = [logicalStateSize]stateMachineStatus{
	stateReject,     // 0
	stateReject,     // 1
	stateReject,     // 2
	stateReject,     // 3
	stateReject,     // 4
	stateReject,     // 5
	stateReject,     // 6
	stateReject,     // 7
	stateRepeatable, // 8
	stateRepeatable, // 9
	stateReject,     // 10
	stateRepeatable, // 11
	stateAccept,     // 12
	stateAccept,     // 13
	stateAccept,     // 14
	stateAccept,     // 15
	stateAccept,     // 16
	stateAccept,     // 17
	stateAccept,     // 18
	stateAccept,     // 19
	stateAccept,     // 20
	stateAccept,     // 21
	stateAccept,     // 22
	stateAccept,     // 23
	stateAccept,     // 24
	stateAccept,     // 25
	stateAccept,     // 26
	stateAccept,     // 27
	stateAccept,     // 28
}

var stateTokenMapping = [logicalStateSize]symbolID{
	invalidToken, // 0
	invalidToken, // 1
	invalidToken, // 2
	invalidToken, // 3
	invalidToken, // 4
	invalidToken, // 5
	invalidToken, // 6
	invalidToken, // 7
	invalidToken, // 8
	invalidToken, // 9
	invalidToken, // 10
	invalidToken, // 11
	label,        // 12
	jumpVerb,     // 13
	mreg,         // 14
	zero,         // 15
	one,          // 16
	areg,         // 17
	dreg,         // 18
	equal,        // 19
	minus,        // 20
	plus,         // 21
	logicalAnd,   // 22
	logicalOr,    // 23
	logicalNot,   // 24
	semicolon,    // 25
	newline,      // 26
	atDigits,     // 27
	atIdentifier, // 28
}

// Scanner scans the input buffer and return TokenID for each scan
type scanner interface {
	scan() (token, error)
}

type scannerType struct {
	reader *bufio.Reader
}

func (tk token) String() string {
	if len(tk.lexeme) == 1 && (tk.lexeme[0] < 32 || tk.lexeme[0] > 126) {
		return fmt.Sprintf("{%s, 0x%X}", tk.id, tk.lexeme)
	}
	return fmt.Sprintf("{%s, %s}", tk.id, tk.lexeme)
}

func newScanner(reader io.Reader) scanner {
	return &scannerType{bufio.NewReader(reader)}
}

func (s *scannerType) scan() (token, error) {
	var lexemeBytes []byte
	state := byte(0)

	for true {
		symbol, err := s.reader.ReadByte()

		logSymbol(symbol)

		// error reading a byte
		if err != nil {
			return token{eoi, ""}, nil
		}

		// skip consecutive spaces
		for symbol == 0x20 && err == nil {
			symbol, err = s.reader.ReadByte()
		}

		// error skipping consecutive spaces
		if err != nil {
			return token{eoi, ""}, nil
		}

		index := transitionIndex[symbol]

		if index == 0xff {
			return token{invalidToken, ""}, errors.New("Invalid token")
		}

		state = transitionTable[index][state]

		if state == 0xff {

			return token{invalidToken, ""}, errors.New("Invalid token")

		} else if stateTokenMapping[state] == atDigits || stateTokenMapping[state] == atIdentifier {

			// this block handles \n at the end of a series of digit/letter scannings
			// if \n is scanned from input unread it and return atDigits/atIdentifier token
			log.Printf("Current symbol is %#x", symbol)
			s.reader.UnreadByte()
			return token{stateTokenMapping[state], string(lexemeBytes)}, nil

		} else if acceptStates[state] == stateAccept {

			lexemeBytes = append(lexemeBytes, symbol)
			return token{stateTokenMapping[state], string(lexemeBytes)}, nil
			// return stateTokenMapping[state], nil

		}

		lexemeBytes = append(lexemeBytes, symbol)
	}

	return token{invalidToken, ""}, nil
}

func logSymbol(symbol byte) {
	if symbol >= 32 && symbol <= 126 {
		log.Printf("Scanned symbol is %c\n", symbol)
	} else {
		log.Printf("Scanned symbol is 0x%X\n", symbol)
	}
}
